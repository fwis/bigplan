<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Babylon.js 虫子与草</title>
    <style>
        html, body {
            width: 100%;
            height: 100%;
            margin: 0;
            overflow: hidden;
        }
        #renderCanvas {
            width: 100%;
            height: 100%;
            touch-action: none;
        }
        #controlPanel {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(255, 255, 255, 0.8);
            padding: 10px;
            border-radius: 5px;
        }
        #controlPanel button,#controlPanel input,#controlPanel span {
            display: block;
            margin: 5px 0;
        }

        #miniMap {
            position: absolute;
            bottom: 10px;
            right: 10px;
            background: rgba(255, 255, 255, 0.8);
            border: 1px solid black;
            width: 200px;
            height: 200px;
        }
    </style>
    <script src="https://cdn.babylonjs.com/babylon.js"></script>
    <script src="https://cdn.babylonjs.com/loaders/babylon.glTF2FileLoader.js"></script>
    <script src="camera.js"></script>
    <script src="world.js"></script>
    <script src="grass.js"></script>
    <script src="worm.js"></script>
</head>
<body>
    <canvas id="renderCanvas"></canvas>
    <div id="controlPanel">
        <input type="number" id="wormCount" placeholder="输入虫子数量" />
        <button id="addWorm">添加虫子</button>
        <input type="number" id="grassCount" placeholder="输入草的数量" />
        <button id="updateGrass">添加草</button>
        <span id="wormCountDisplay">虫子数量: 0</span>
        <span id="grassCountDisplay">草的数量: 0</span>
        <button id="toggleMovement">暂停虫子运动</button>
        <label for="speedControl">虫子速度</label>
        <input type="range" id="speedControl" min="0.01" max="1" step="0.01" value="0.1">
        <span id="speedDisplay">当前速度: 0.1</span>
    </div>
    <canvas id="miniMap"></canvas>
    <script>
        // 获取canvas元素
        var canvas = document.getElementById("renderCanvas");
        var miniMapCanvas = document.getElementById("miniMap");
        var miniMapContext = miniMapCanvas.getContext("2d");

        // 创建Babylon引擎
        var engine = new BABYLON.Engine(canvas, true);
<<<<<<< HEAD
        var world = new World(1000, miniMapCanvas);
        var camera = null;
=======
        var worms = []; // 存储虫子的数组
        var wormTemplate = null;
        var grassInstances = []; // 存储草实例的数组
        var movementEnabled = true; // 控制虫子运动的开关
        var groundSize = 2000; // 地面尺寸
        var grassContainer = null;
        var singleGrassTemplate = null;
        var flowerGrassTemplate = null;
        var denseGrassTemplate = null;

        // 虫子类定义
        class Worm {
            constructor(instance) {
                this.instance = instance;
                this.position = instance.position;
                this.rotation = instance.rotation;
                this.speed = 1;
            }

            move(direction) {
                let moveVector;
                switch (direction) {
                    case "forward":
                        moveVector = new BABYLON.Vector3(Math.sin(this.rotation.y) * this.speed, 0, Math.cos(this.rotation.y) * this.speed);
                        this.position.addInPlace(moveVector);
                        break;
                    case "backward":
                        this.rotation.y += Math.PI; // 转到反方向
                        break;
                    case "left":
                        this.rotation.y -= Math.PI / 2; // 左转90度
                        break;
                    case "right":
                        this.rotation.y += Math.PI / 2; // 右转90度
                        break;
                }
                this.clampToGround();
            }

            randomMove() {
                let directions = ["forward", "backward", "left", "right"];
                this.move(directions[Math.floor(Math.random() * directions.length)]);
            }

            clampToGround() {
                var halfSize = groundSize / 2;
                this.position.x = Math.max(-halfSize, Math.min(halfSize, this.position.x));
                this.position.z = Math.max(-halfSize, Math.min(halfSize, this.position.z));
            }

            updateSpeed(newSpeed) {
                this.speed = newSpeed;
            }
        }
>>>>>>> 03aabe34cbe92ee06855678b0b087df57edb5ec3

        // 创建场景的函数
        var createScene = function () {
            var scene = new BABYLON.Scene(engine);
            scene.collisionsEnabled = true;
            world.scene = scene;

            // 创建相机
            //camera = new BABYLON.ArcRotateCamera("camera", Math.PI / 2, Math.PI / 3, 200, new BABYLON.Vector3(0, 0, 0), scene);
            //camera.attachControl(canvas, true);
            camera = new CustomCamera("customCamera", new BABYLON.Vector3(0, 100, 0), scene);
            camera.ellipsoid = new BABYLON.Vector3(1, 1, 1);
            camera.checkCollisions = true;
            camera.attachControl(canvas, false);
            
            var light1 = new BABYLON.HemisphericLight("light1", new BABYLON.Vector3(0, 1, 0), scene);
            light1.groundColor = new BABYLON.Color3(0.5, 0.5, 0.5); // 下半球光照强度
            light1.specular = new BABYLON.Color3(0.3, 0.3, 0.3); // 上半球光照强度
            light1.intensity = 1.0;
            

            // 创建地面
            var ground = BABYLON.MeshBuilder.CreateGround("ground", {width: world.WorldSize, height: world.WorldSize}, scene);
            var groundMaterial = new BABYLON.StandardMaterial("groundMaterial", scene);
            //groundMaterial.diffuseTexture = new BABYLON.Texture("https://www.babylonjs-playground.com/textures/grass.png", scene);
            groundMaterial.diffuseTexture = new BABYLON.Texture("ground0.png", scene);
            groundMaterial.diffuseTexture.uScale = 50;
            groundMaterial.diffuseTexture.vScale = 50;
            ground.material = groundMaterial;
            ground.checkCollisions = true;

            // 创建天空盒
            var skybox = BABYLON.MeshBuilder.CreateBox("skyBox", {
                width: world.WorldSize - 1,
                height: world.WorldSize * 3,
                depth: world.WorldSize - 1
                }, scene);
            var skyboxMaterial = new BABYLON.StandardMaterial("skyBoxMaterial", scene);
            skyboxMaterial.backFaceCulling = false;
            skyboxMaterial.reflectionTexture = new BABYLON.CubeTexture("https://www.babylonjs-playground.com/textures/skybox", scene);
            skyboxMaterial.reflectionTexture.coordinatesMode = BABYLON.Texture.SKYBOX_MODE;
            skyboxMaterial.diffuseColor = new BABYLON.Color3(0, 0, 0);
            skyboxMaterial.specularColor = new BABYLON.Color3(0, 0, 0);
            skybox.material = skyboxMaterial;
            skybox.checkCollisions = false;

            world.LoadGrassModel("");
            world.LoadWormModel("worm2.glb");

<<<<<<< HEAD
=======
                // 循环遍历实例的根节点，随机设置位置
                for (var node of entries.rootNodes) {
                    node.position.x += Math.random() * 1000 - 500; // 随机设置 x 坐标
                    node.position.y = 0.5; // 设置 y 坐标
                    node.position.z += Math.random() * 1000 - 500; // 随机设置 z 坐标
                }
            };

            // 使用 BABYLON.SceneLoader 加载 worm2.glb 模型文件
            BABYLON.SceneLoader.LoadAssetContainer("", "worm2.glb", scene, function (container) {
                // 将所有模型元素添加到场景中
                container.addAllToScene();

                // 过滤几何体网格，并将它们合并成一个网格 wormTemplate
                mymeshes = container.meshes.filter(mesh => mesh.geometry);
                wormTemplate = BABYLON.Mesh.MergeMeshes(mymeshes, true, false, null, false, true);
            });

            grassContainer = new BABYLON.TransformNode("grassContainer", scene);

            // 返回创建的场景对象
>>>>>>> 03aabe34cbe92ee06855678b0b087df57edb5ec3
            return scene;
        };

        // 添加虫子按钮事件
        document.getElementById("addWorm").addEventListener("click", function() {
            var count = parseInt(document.getElementById("wormCount").value) || 1;

            for (var i = 0; i < count; i++) {
                const x = Math.random() * world.WorldSize - world.WorldSize/2;
                const z = Math.random() * world.WorldSize - world.WorldSize/2;
                const rotation = Math.random() * Math.PI * 2 - Math.PI;

                world.CreateWorm(x, z, rotation);
            }
        });

        // 更新草数量按钮事件
        document.getElementById("updateGrass").addEventListener("click", function() {
            var count = parseInt(document.getElementById("grassCount").value) || 1;

            for (var i = 0; i < count; i++) {
                const x = Math.random() * world.WorldSize - world.WorldSize/2;
                const z = Math.random() * world.WorldSize - world.WorldSize/2;
                const rotation = Math.random() * Math.PI * 2 - Math.PI;

                world.CreateGrass(x, z, rotation);
            }
        });

        // 暂停虫子运动按钮事件
        document.getElementById("toggleMovement").addEventListener("click", function() {
            world.toggleWormMovement();
        });

        // 更新虫子速度事件
        document.getElementById("speedControl").addEventListener("input", function() {
            var speed = parseFloat(document.getElementById("speedControl").value);
            world.updateWormSpeed(speed);
            document.getElementById("speedDisplay").textContent = `当前速度: ${speed.toFixed(2)}`;
        });

        var scene = createScene();
        
        scene.registerBeforeRender(() => {
            const worldSize = world.WorldSize/2 - 2;
            if (!camera || worldSize <= 0) return;

            const pos = camera.position;
            pos.x = Math.max(-worldSize, Math.min(worldSize, pos.x));
            //pos.y = Math.max(-limit, Math.min(limit, pos.y));
            pos.z = Math.max(-worldSize, Math.min(worldSize, pos.z));
            
            // 绘制小地图
            miniMapContext.clearRect(0, 0, miniMapCanvas.width, miniMapCanvas.height);
            miniMapContext.strokeStyle = 'black';
            miniMapContext.strokeRect(0, 0, miniMapCanvas.width, miniMapCanvas.height);

            // 将虫子和草绘制在小地图上
            world.worms.forEach(worm => {
                world.drawOnMiniMap(miniMapContext, miniMapCanvas, worm.wormMesh.position, 'red');
            });
            world.grasses.forEach(grass => {
                world.drawOnMiniMap(miniMapContext, miniMapCanvas, grass.grassMesh.position, 'green');
            });
        });

        // 开始渲染循环
        engine.runRenderLoop(function () {
            scene.render();
            world.RunFrame();
        });

        // 调整窗口大小时更新引擎大小
        window.addEventListener("resize", function () {
            engine.resize();
        });
<<<<<<< HEAD
    </script>
</body>
=======

        // 更新显示数量的函数
        function updateCountDisplay() {
            document.getElementById("wormCountDisplay").innerText = "虫子数量: " + worms.length;
            document.getElementById("grassCountDisplay").innerText = "草的数量: " + grassInstances.length;
        }

        // 创建单草的函数
        function createSingleGrass(scene) {
            var items = [];
            for (var i = 0; i < 5; i++) {
                var blade = BABYLON.MeshBuilder.CreateCylinder("blade", {
                    height: 12, // 放大草的高度
                    diameterTop: 0,
                    diameterBottom: 1.2, // 放大草的底部直径
                    tessellation: 3
                }, scene);
                blade.material = new BABYLON.StandardMaterial("grassMaterial", scene);
                blade.material.diffuseColor = new BABYLON.Color3(0, 1, 0);
                blade.position.y = 6;
                blade.rotation.z = Math.PI / 6 * (i - 2);
                items.push(blade);
            }

            var combinedMesh = BABYLON.Mesh.MergeMeshes(items, true, false, null, false, true);
            combinedMesh.position.y = -3;
            combinedMesh.setEnabled(false);
            return combinedMesh;
        }

        function createFlowerGrass(scene) {
            var items = [];
            for (var i = 0; i < 5; i++) {
                var blade = BABYLON.MeshBuilder.CreateCylinder("blade", {
                    height: 12,
                    diameterTop: 0,
                    diameterBottom: 1.2,
                    tessellation: 3
                }, scene);
                blade.material = new BABYLON.StandardMaterial("grassMaterial", scene);
                blade.material.diffuseColor = new BABYLON.Color3(0, 1, 0);
                blade.position.y = 6;
                blade.rotation.z = Math.PI / 6 * (i - 2);
                items.push(blade);
            }
            var flowerRadius = 0.6;
            var flowerCount = 5;
            for (var i = 0; i < flowerCount; i++) {
                var angle = (i / flowerCount) * 2 * Math.PI;
                var flowerPetal = BABYLON.MeshBuilder.CreateSphere("flowerPetal" + i, { diameter: 0.4 }, scene);
                flowerPetal.material = new BABYLON.StandardMaterial("flowerMaterial", scene);
                flowerPetal.material.diffuseColor = new BABYLON.Color3(1, 0, 0);
                flowerPetal.position.y = 12;
                flowerPetal.position.x = Math.cos(angle) * flowerRadius;
                flowerPetal.position.z = Math.sin(angle) * flowerRadius;
                items.push(flowerPetal);
            }
            var combinedMesh = BABYLON.Mesh.MergeMeshes(items, true, false, null, false, true);
            combinedMesh.position.y = -3;
            combinedMesh.setEnabled(false);
            return combinedMesh;
        }

        function createDenseGrass(scene) {
            var items = [];
            for (var i = 0; i < 7; i++) {
                var grass = createSingleGrass(scene);
                grass.scaling = new BABYLON.Vector3(1, 1.5, 1); // 将草丛高度增加到2倍
                grass.rotation.y = (Math.PI / 3.5) * i;
                items.push(grass);
            }
            var combinedMesh = BABYLON.Mesh.MergeMeshes(items, true, false, null, false, true);
            combinedMesh.position.y = -3;
            combinedMesh.setEnabled(false);
            return combinedMesh;
        }

        // 生成草的函数
        function generateGrass(scene, grassCount) {
            if (grassContainer) {
                grassContainer.dispose();
            }
            grassContainer = new BABYLON.TransformNode("grassContainer", scene);

            for (var i = 0; i < grassCount; i++) {
                var grass;
                var rand = Math.random();

                if (!singleGrassTemplate) {
                    singleGrassTemplate = createSingleGrass(scene);
                }
                if (!flowerGrassTemplate) {
                    flowerGrassTemplate = createFlowerGrass(scene);
                }
                if (!denseGrassTemplate) {
                    denseGrassTemplate = createDenseGrass(scene);
                }

                if (rand < 0.33) {
                    grass = singleGrassTemplate.createInstance("singleGrass" + i);
                } else if (rand < 0.66) {
                    grass = flowerGrassTemplate.createInstance("flowerGrass" + i);
                } else {
                    grass = denseGrassTemplate.createInstance("denseGrass" + i);
                }

                grass.position.x = Math.random() * 1000 - 500;
                grass.position.z = Math.random() * 1000 - 500;
                grass.parent = grassContainer;
                grass.position.y = -6;
                grassInstances.push(grass); // 添加到实例数组
            }
            updateCountDisplay();
        }

        document.getElementById("moveForward").addEventListener("click", function () {
            worms.forEach(worm => worm.move("forward"));
        });

        document.getElementById("moveBackward").addEventListener("click", function () {
            worms.forEach(worm => worm.move("backward"));
        });
        document.getElementById("moveLeft").addEventListener("click", function () {
            worms.forEach(worm => worm.move("left"));
        });

        document.getElementById("moveRight").addEventListener("click", function () {
            worms.forEach(worm => worm.move("right"));
        });

        document.getElementById("addWorm").addEventListener("click", function () {
            var count = parseInt(document.getElementById("wormCount").value);
            if (isNaN(count) || count <= 0) {
                console.error("Invalid worm count");
                return;
            }

            for (var i = 0; i < count; i++) {
                var wormInstance = wormTemplate.createInstance("worm" + (worms.length + i));
                wormInstance.position.x = Math.random() * 1000 - 500;
                wormInstance.position.y = 0.5;
                wormInstance.position.z = Math.random() * 1000 - 500;
                wormInstance.rotation.y = Math.random() * 2 * Math.PI; // 随机设置朝向
                worms.push(new Worm(wormInstance));
            }
            updateCountDisplay();
        });

        document.getElementById("updateGrass").addEventListener("click", function () {
            var grassCount = parseInt(document.getElementById("grassCount").value);
            if (isNaN(grassCount) || grassCount <= 0) {
                console.error("Invalid grass count");
                return;
            }

            generateGrass(scene, grassCount);
        });

        // 控制虫子运动按钮事件
        document.getElementById("toggleMovement").addEventListener("click", function () {
            movementEnabled = !movementEnabled;
            document.getElementById("toggleMovement").innerText = movementEnabled ? "暂停虫子运动" : "开启虫子运动";
        });

        // 速度控制事件
        document.getElementById("speedControl").addEventListener("input", function (event) {
            var speed = parseFloat(event.target.value);
            document.getElementById("speedDisplay").innerText = "当前速度: " + speed;
            worms.forEach(worm => worm.updateSpeed(speed));
        });

        // 更新小地图
        function updateMiniMap() {
            miniMapContext.clearRect(0, 0, miniMapCanvas.width, miniMapCanvas.height);
            miniMapContext.fillStyle = "red";
            worms.forEach(worm => {
                var x = (worm.position.x + groundSize / 2) / groundSize * miniMapCanvas.width;
                var z = (worm.position.z + groundSize / 2) / groundSize * miniMapCanvas.height;
                miniMapContext.beginPath();
                miniMapContext.arc(x, z, 3, 0, 2 * Math.PI);
                miniMapContext.fill();
            });
        }
    </script>
</body>

>>>>>>> 03aabe34cbe92ee06855678b0b087df57edb5ec3
</html>
